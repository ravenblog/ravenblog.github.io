<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>mysql执行DDL过程探究</title>
    <link href="/2021/12/27/mysql%E6%89%A7%E8%A1%8CDDL%E8%BF%87%E7%A8%8B%E6%8E%A2%E7%A9%B6/"/>
    <url>/2021/12/27/mysql%E6%89%A7%E8%A1%8CDDL%E8%BF%87%E7%A8%8B%E6%8E%A2%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="一，探究背景"><a href="#一，探究背景" class="headerlink" title="一，探究背景"></a>一，探究背景</h2><p>其他组的同事需要对两个表之间进行连接查询，例如：t1表和t2。两表之间用’merchant_id’进行连接查询，两个表中的 merchant_id 含义完全相同，指的是商家 ID。 但是，在表模式中，它们属于不同的表类型。</p><ol><li> t1-&gt; `merchant_id` varchar(64) COLLATE utf8mb4_unicode_ci NOT NULL</li><li> t2-&gt; `merchant_id` varchar(48) COLLATE utf8_unicode_ci NOT NULL</li></ol><p>在用Merchant_id进行连接查询时，因为数据类型不同。 未使用t2 中的索引，导致查询缓慢。</p><p>经过讨论发现，我们需要对t2表执行以下DDL操作：</p><p><code>-- +migrate Up</code></p><p><code>ALTER</code> <code>TABLE</code> <code>`t2`</code></p><p><code>MODIFY</code> <code>COLUMN</code> <code>`merchant_id`</code> <code>varchar``(64)</code> <code>COLLATE</code> <code>utf8mb4_unicode_ci</code> <code>NOT</code> <code>NULL``;</code></p><p><code>-- +migrate Down</code></p><p><code>ALTER</code> <code>TABLE</code> <code>`t2`</code></p><p><code>MODIFY</code> <code>COLUMN</code> <code>`merchant_id`</code> <code>varchar``(48)</code> <code>COLLATE</code> <code>utf8_unicode_ci</code> <code>NOT</code> <code>NULL``;</code></p><p>可是，对一个存储了上百万甚至上千上万的数据表进行 DDL 操作，数据库是怎么做到的呢？会不会有一个很大的事务锁？会不会影响数据的插入和更新？今天就聊聊这个问题。</p><h2 id="二，实验探究"><a href="#二，实验探究" class="headerlink" title="二，实验探究"></a>二，实验探究</h2><p>实验准备：新建merchant_users表</p><p><code>CREATE</code> <code>TABLE</code> <code> `merchant_users` (</code></p><p><code>`id`</code> <code>int``(11)</code> <code>NOT</code> <code>NULL</code> <code>AUTO_INCREMENT,</code></p><p><code>`email`</code> <code>varchar``(128)</code> <code>NOT</code> <code>NULL``,</code></p><p><code>`merchant_id`</code> <code>varchar``(48)</code> <code>NOT</code> <code>NULL``,</code></p><p><code>`updated_at`</code> <code>timestamp</code> <code>NOT</code> <code>NULL</code> <code>DEFAULT</code> <code>CURRENT_TIMESTAMP</code> <code>ON</code> <code>UPDATE</code> <code>CURRENT_TIMESTAMP``,</code></p><p><code>`created_at`</code> <code>timestamp</code> <code>NOT</code> <code>NULL</code> <code>DEFAULT</code> <code>CURRENT_TIMESTAMP``,</code></p><p><code>PRIMARY</code> <code>KEY</code> <code>(`id`),</code></p><p><code>UNIQUE</code> <code>KEY</code> <code> `index_merchant_users_email` (`email`),</code></p><p><code>KEY</code> <code> `index_merchant_users_created_at` (`created_at`),</code></p><p><code>KEY</code> <code> `index_merchant_users_updated_at` (`updated_at`),</code></p><p><code>KEY</code> <code> `index_merchant_users_merchant_id` (`merchant_id`)</code></p><p><code>) ENGINE=InnoDB</code> <code>DEFAULT</code> <code>CHARSET=utf8;</code></p><h3 id="（1）实验一"><a href="#（1）实验一" class="headerlink" title="（1）实验一"></a>（1）实验一</h3><p>1，登陆mysql数据库，数据库版本为5.7.35</p><p><code>ITCN000613-MAC:~ ruiwen.ding$ mysql -u root -p</code></p><p><code>Enter password:</code></p><p><code>Welcome to the MySQL monitor.  Commands end with ; or \g.</code></p><p><code>Your MySQL connection</code> <code>id</code> <code>is 5</code></p><p><code>Server version: 5.7.35 Homebrew</code></p><p>2，查看所有的Database</p><p><code>mysql&gt; show databases;</code></p><p><code>+--------------------+</code></p><p><code>| Database           |</code></p><p><code>+--------------------+</code></p><p><code>| information_schema |</code></p><p><code>| dormammu           |</code></p><p><code>| hela               |</code></p><p><code>| hellfire           |</code></p><p><code>| kingpin            |</code></p><p><code>| magneto            |</code></p><p><code>| merchants_test     |</code></p><p><code>| mysql              |</code></p><p><code>| patronus           |</code></p><p><code>| performance_schema |</code></p><p><code>| shield             |</code></p><p><code>| sys                |</code></p><p><code>| todolist           |</code></p><p><code>+--------------------+</code></p><p><code>13 rows</code> <code>in</code> <code>set</code> <code>(0.00 sec)</code></p><p>3，在merchants_test表上执行DDL语句。</p><p><code>mysql&gt; use merchants_test;</code></p><p><code>Database changed</code></p><p><code>mysql&gt; ALTER TABLE `merchant_users` </code></p><p><code>-&gt; MODIFY COLUMN `merchant_id` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT</code> <code>&#39;&#39;``;</code></p><p><code>Query OK, 2 rows affected (0.03 sec)</code></p><p><code>Records: 2  Duplicates: 0  Warnings: 0</code></p><p>4，进入/usr/local/var/mysql/merchants_test，执行stat merchant_users.frm及merchant_users.ibd命令，结果显示新建了merchant_users.frm及merchant_users.ibd文件。</p><p><code>ITCN000613-MAC:merchants_test ruiwen.ding$ stat merchant_users.frm</code></p><p><code>16777221 8679142 -rw-r----- 1 ruiwen.ding admin 0 13166</code> <code>&quot;Nov 12 11:28:02 2021&quot;</code> <code>&quot;Nov 12 11:28:02 2021&quot;</code> <code>&quot;Nov 12 11:28:02 2021&quot;</code> <code>&quot;Nov 12 11:28:02 2021&quot;</code> <code>4096 32 0 merchant_users.frm</code></p><p><code>ITCN000613-MAC:merchants_test ruiwen.ding$ stat merchant_users.ibd</code></p><p><code>16777221 8679143 -rw-r----- 1 ruiwen.ding admin 0 180224</code> <code>&quot;Nov 12 11:28:02 2021&quot;</code> <code>&quot;Nov 12 11:28:04 2021&quot;</code> <code>&quot;Nov 12 11:28:04 2021&quot;</code> <code>&quot;Nov 12 11:28:02 2021&quot;</code> <code>4096 352 0 merchant_users.ibd</code></p><h3 id="（2）实验二："><a href="#（2）实验二：" class="headerlink" title="（2）实验二："></a>（2）实验二：</h3><p>1，在merchant_users表上再次执行DDL语句</p><p><code>mysql&gt; ALTER TABLE `merchant_users` MODIFY COLUMN `merchant_id` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT</code> <code>&#39;1&#39;``;</code></p><p><code>Query OK, 0 rows affected (0.02 sec)</code></p><p><code>Records: 0  Duplicates: 0  Warnings: 0</code></p><p>2，利用进入/usr/local/var/mysql/merchants_test，执行stat merchant_users.frm及merchant_users.ibd命令</p><p><code>ITCN000613-MAC:merchants_test ruiwen.ding$ stat merchant_users.frm</code></p><p><code>16777221 8682453 -rw-r----- 1 ruiwen.ding admin 0 13166</code> <code>&quot;Nov 12 11:43:55 2021&quot;</code> <code>&quot;Nov 12 11:43:55 2021&quot;</code> <code>&quot;Nov 12 11:43:55 2021&quot;</code> <code>&quot;Nov 12 11:43:55 2021&quot;</code> <code>4096 32 0 merchant_users.frm</code></p><p><code>ITCN000613-MAC:merchants_test ruiwen.ding$ stat merchant_users.ibd</code></p><p><code>16777221 8679143 -rw-r----- 1 ruiwen.ding admin 0 180224</code> <code>&quot;Nov 12 11:28:02 2021&quot;</code> <code>&quot;Nov 12 11:28:04 2021&quot;</code> <code>&quot;Nov 12 11:28:04 2021&quot;</code> <code>&quot;Nov 12 11:28:02 2021&quot;</code> <code>4096 352 0 merchant_users.ibd</code></p><p><code>ITCN000613-MAC:merchants_test ruiwen.ding$</code></p><p>执行DDL文件为什么要新建table.frm及table.idb文件？那为什么有时候又不需要新建呢？</p><h2 id="三，早期DDL实现原理"><a href="#三，早期DDL实现原理" class="headerlink" title="三，早期DDL实现原理"></a>三，早期DDL实现原理</h2><ul><li><p>COPY：对原始 table 的副本执行操作，并将 table 数据从原始 table 逐行复制到新 table  </p></li><li><p>IN-PLACE：在在 MySQL 5.5 版本中，增加了 IN-Place 方式。所谓 IN-Place 方式，就是索引创建在原表上直接进行，不会 COPY 整个表，只需要在原来的 idb 文件上，新建所需要的索引页，<br>这比COPY算法极大的节约IO资源，且减少了DDL执行时长。  </p><p>COPY算法步骤：</p></li></ul><p>1，新建跟原表格一致的临时表，并在该临时表上执行DDL语句</p><p>2，拿MDL写锁</p><p>3，从原表中拷贝数据到临时表，此时其他会话仍然可以对原表进行读操作(有例外)</p><p>4，拷贝结束后，原表禁止读写操作，直到准备好新 table</p><p>5，执行rename操作</p><p>6，释放MDL写锁，DDL操作完成</p><p>IN-PLACE步骤：</p><p>1，新建frm临时文件</p><p>2，拿MDL写锁</p><p>3，按照聚集索引的顺序，查询数据，找到需要的索引列数据，排序后插入到新的索引页中</p><p>4，原表禁止读操作，也就是原表此时不提供读写服务</p><p>5，执行rename操作</p><p>6，释放MDL写锁，DDL操作完成</p><p>The exception referred to earlier is that ALTER TABLE blocks reads (not just writes) at the point where it is ready to install a new version of the table .frm file, discard the old file, and clear outdated table structures from the table and table definition caches. At this point, it must acquire an exclusive lock. To do so, it waits for current readers to finish, and blocks new reads and writes.</p><h4 id="copy算法分析："><a href="#copy算法分析：" class="headerlink" title="copy算法分析："></a><strong>copy算法分析：</strong></h4><p>MDL读锁之间不互斥，因此可以有多个线程同时对一张表进行增删改查，读写锁之间，写锁之间是互斥的。因此要有两个会话同时给一个表加字段，其中一个要等另一个执行完才能执行。因为MDL锁之间的互斥，所以在执行DDL操作的时候会造成session之间的一个阻塞。我们来看一下下面的操作示例，假设存在数据库表t。</p><table><thead><tr><th>session A</th><th>session B</th><th>session C</th><th>session D</th></tr></thead><tbody><tr><td>session A</td><td>session B</td><td>session C</td><td>session D</td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>begin</td><td></td><td></td><td></td></tr><tr><td>update table t</td><td></td><td></td><td></td></tr><tr><td></td><td>update table t</td><td></td><td></td></tr><tr><td></td><td></td><td>alert table t modify column ‘id’ varchar(64)<br><br>(blocked)</td><td></td></tr><tr><td></td><td></td><td></td><td>update table t<br><br>（blocked）</td></tr></tbody></table><p>我们可以看到session A先开始执行，获得MDL读锁，紧接着session B开始执行，因为MDL读锁之间不互斥，所以sessionB可以正常执行。</p><p>之后sessionC需要一个MDL写锁，因为MDL读锁和写锁之间是互斥的，他必须等待session A释放MDL读锁，所以session C变为阻塞状态，类似的session D也需要申请读锁，所以同样会变为阻塞状态。我们知道所有对表的增删改查都需要先获得读锁，因此如果session D后面再有其他session请求的话，都会被锁住，导致这个表完全不可读写。</p><p> 根据上面的例子可以看出，在mysql5.5版本上直接执行DDL语句是相当危险的，那有什么办法可以较为安全的执行DDL操作呢？</p><p>只要思想不滑坡，办法总比困难多，在mysql5.5版本中较安全的执行DDL操作，有几下几种常用办法：</p><p>1，事务不提交就一直会占用着DDL读锁，所以只要在DDL执行期间手动kill掉长事物，尽量保证不要有长事物执行就可以相对安全的执行DDL操作，当然这种方法只对小表有用，对于请求频繁的大表就不适用了。</p><p>2，在alert table语句里面设置等待时间，在等待时间内获取到MDL写锁最好，如果获取不到先放弃，不要阻塞后面的业务语句。</p><p>3，先在一台不提供服务的机器上使用alert操作，然后和提供服务的主库进行切换</p><p>4，使用“影子拷贝”，用要求的表结构创建一张和源表无关的新表，然后通过重命名等方式交换两张表。（percona toolkit——–pt-online-schema-change）</p><h2 id="四，MySQL-Online-DDL"><a href="#四，MySQL-Online-DDL" class="headerlink" title="四，MySQL Online DDL"></a>四，MySQL Online DDL</h2><p>mysql5.5版本中的DDL操作因为会锁表广受人诟病，虽然引入了 INPLACE DDL 方式，但是因为实现的问题，依然会阻塞 INSERT、UPDATE、DELETE 操作，并且其应用范围不够广泛，导致mysql5.5版本一直被大家吐槽。</p><p>为了改善这一现状，mysql在5.6版本中开始支持更多的 INPLACE DDL 避免数据 COPY 的开销，同时引入了online DDL，通过这种方式可以在执行DDL 的过程中不阻塞 MDL 操作。</p><ul><li>  Online DDL的过程大致如下：</li></ul><p>1，新建frm文件</p><p>2，拿MDL写锁</p><p>3，降级成MDL读锁</p><p>4，真正做DDL</p><p>5，升级成MDL读锁</p><p>6，释放MDL写锁，DDL操作完成</p><p><code>Alter</code> <code>table</code> <code>…. , ALGORITHM [=] &#123;``DEFAULT``|INPLACE|COPY&#125;, LOCK [=] &#123;</code> <code>DEFAULT``| NONE| SHARED| EXCLUSIVE &#125;</code></p><p>ALGORITHM 子句指定执行 DDL 采用的方式，LOCK 子句描述持有锁类型来控制 MDL 的并发。其中，某些 DDL 语句不支持 Online DDL 的采用 COPY 方式，支持的就采用 INPLACE 方式  </p><p>这里的Inplace又区分为2类：</p><ul><li>  rebuild table:是否修改行记录格式。如果修改了行记录格式，则需要rebuild表格，比如修改列类型、增减列等</li><li>no-rebuild table:如果没有修改行记录格式，仅修改表的元数据，则不需要rebuild表格，仅修改元数据 metadata，比如删除索引、设置默认值及重命名列名等</li></ul><p>部分可见下表：</p><ol><li><p>Online DDL对索引操作的支持</p><table><thead><tr><th>操作</th><th><strong>INPLACE</strong></th><th>重建表</th><th>支持并发DML</th><th><strong>仅修改元数据</strong></th></tr></thead><tbody><tr><td>操作</td><td><strong>INPLACE</strong></td><td>重建表</td><td>支持并发DML</td><td><strong>仅修改元数据</strong></td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>创建或新增一个二级索引</td><td>YES</td><td>NO</td><td>YES</td><td>NO</td></tr><tr><td>删除索引</td><td>YES</td><td>NO</td><td>YES</td><td>YES</td></tr><tr><td>重命名索引</td><td>YES</td><td>NO</td><td>YES</td><td>YES</td></tr><tr><td>增加全文索引</td><td>YES</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>增加空间索引</td><td>YES</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>修改索引类型</td><td>YES</td><td>NO</td><td>YES</td><td>YES</td></tr></tbody></table></li><li><p>Online DDL对主键操作的支持</p><table><thead><tr><th>操作</th><th><strong>INPLACE</strong></th><th>重建表</th><th>支持并发DML</th><th><strong>仅修改元数据</strong></th></tr></thead><tbody><tr><td>操作</td><td><strong>INPLACE</strong></td><td>重建表</td><td>支持并发DML</td><td><strong>仅修改元数据</strong></td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>添加主键</td><td>YES</td><td>YES</td><td>YES</td><td>NO</td></tr><tr><td>删除主键</td><td>NO</td><td>YES</td><td>NO</td><td>NO</td></tr><tr><td>重建主键</td><td>YES</td><td>YES</td><td>YES</td><td>NO</td></tr></tbody></table><p>更多请参考：<a href="https://drive.google.com/file/d/1gEDoCPd-vrjIpfawiyb9IVxu7FLruTxn/view?usp=sharing">https://drive.google.com/file/d/1gEDoCPd-vrjIpfawiyb9IVxu7FLruTxn/view?usp=sharing</a></p></li></ol><h2 id="五，各类DDL执行方式对比"><a href="#五，各类DDL执行方式对比" class="headerlink" title="五，各类DDL执行方式对比"></a>五，各类DDL执行方式对比</h2><table><thead><tr><th>方法</th><th>copy</th><th>Inplace-not rebuild</th><th>Inplace-rebuild</th><th>pt-online-schema-change</th></tr></thead><tbody><tr><td>方法</td><td>copy</td><td>Inplace-not rebuild</td><td>Inplace-rebuild</td><td>pt-online-schema-change</td></tr><tr><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>DDL过程中读取数据</td><td>需要</td><td>需要</td><td>允许</td><td>允许</td></tr><tr><td>DDL过程中写入数据</td><td>不需要</td><td>需要</td><td>允许</td><td>允许</td></tr><tr><td>是否需要MDL</td><td>需要</td><td>需要</td><td>需要</td><td>需要</td></tr><tr><td>是否需要额外空间</td><td>大</td><td>小</td><td>中</td><td>大</td></tr><tr><td>执行时间</td><td>非常大</td><td>短</td><td>非常长</td><td>长</td></tr><tr><td>IO负载</td><td>大</td><td>小</td><td>大</td><td>非常大</td></tr><tr><td>导致主从同步延迟</td><td>非常大</td><td>大</td><td>大</td><td>小</td></tr></tbody></table><p>需要注意的是所有方式做 DDL 均会引发主从同步延时。其中 copy 和 inplace 算法，只有主完成了 DDL 操作之后，binlog 才会同步给从库，从库才能开始操作 DDL，从库操作完 DDL 之后才能开始操作其他语句，因此会造成巨大的（大概两倍 DDL 操作时间）的延时。其他方法产生的延时较小，但仍然可能有几秒的延时。</p><h2 id="六，问题讨论"><a href="#六，问题讨论" class="headerlink" title="六，问题讨论"></a>六，问题讨论</h2><p>最后讨论几个容易混淆的问题</p><p>1，Online DDL会锁表吗？</p><p>2，Online DDL拿到MDL写锁又会降级成MDL读锁，为什么不直接拿MDL读锁呢？</p><p>3，采用INPLACE 方式也可能会rebuild table，这种情况下和COPY算法有什么区别？</p><p>4，支持 INPLACE 算法的 DDL 一定是 Online 的吗？</p><p>5，无论DDL以COPY算法执行还是以INPLACE算法执行，DDL操作对索引有什么影响？</p><h2 id="七，总结"><a href="#七，总结" class="headerlink" title="七，总结"></a>七，总结</h2><p>传统的 DDL，采用COPY算法对原始 table 的副本执行操作，并将 table 数据从原始 table 逐行复制到新 table，不支持并发 MDL，整个过程还需要获得MDL写锁，整个过程不但及其耗费资源，还容易导致mysql线程爆满。虽然在 MySQL 5.5 版本中，支持IN-PLACE算法，优化了对索引的操作，避免数据 COPY 的开销，但因为实用场景少且IN-PLACE也需要获得MDL锁，效果并不理想。在 MySQL 5.6 开始增强了INPLACE算法，避免数据 COPY 的开销，同时增加了 Online DDL 功能，使得可以并发执行 MDL 操作，大大减轻了数据库 CPU、IO 等性能的消耗。</p><h2 id="各版本支持"><a href="#各版本支持" class="headerlink" title="各版本支持"></a>各版本支持</h2><ul><li>  mysql5.6:<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-online-ddl-operations.html">https://dev.mysql.com/doc/refman/5.6/en/innodb-online-ddl-operations.html</a></li><li>  mysql5.7:<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-online-ddl-operations.html">https://dev.mysql.com/doc/refman/5.7/en/innodb-online-ddl-operations.html</a></li><li>  mysql8.0:<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-online-ddl-operations.html">https://dev.mysql.com/doc/refman/8.0/en/innodb-online-ddl-operations.html</a></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>【1】MySQL · 源码阅读 · 白话Online DDL，阿里云RDS-数据库内核组-数据库内核月报(2021/03)，<a href="http://mysql.taobao.org/monthly/2021/03/06/">http://mysql.taobao.org/monthly/2021/03/06/</a></p><p>【2】林晓斌，MySQL实战45讲，极客时间(2018)，<a href="https://time.geekbang.org/column/intro/100020801?tab=comment">https://time.geekbang.org/column/intro/100020801?tab=comment</a></p><p>【3】张松林，浅谈 DDL 技术解密，松然聊技术(2019)，<a href="https://toutiao.io/posts/fh5ss0/preview">https://toutiao.io/posts/fh5ss0/preview</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql执行计划分析</title>
    <link href="/2021/11/29/mysql%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E5%88%86%E6%9E%90/"/>
    <url>/2021/11/29/mysql%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>如何能使mysql以更高的性能执行查询语句?要回答这一问题我们首先需要弄清楚mysql内部是怎么执行查询语句的，只要知道了这一点，找出mysql在执行过程中的性能瓶颈，做针对性的优化就能使查询语句以预期合理的方式运行，真正做到高性能mysql。</p><h2 id="mysql执行计划分析"><a href="#mysql执行计划分析" class="headerlink" title="mysql执行计划分析"></a>mysql执行计划分析</h2><h3 id="mysql查询执行的基础"><a href="#mysql查询执行的基础" class="headerlink" title="mysql查询执行的基础"></a>mysql查询执行的基础</h3><p>如何能使mysql以更高的性能执行查询语句?要回答这一问题我们首先需要弄清楚mysql内部是怎么执行查询语句的，做到不仅到知其然而且知其所以然。只要知道了这一点，找出mysql在执行过程中的性能瓶颈，做针对性的优化就能使查询语句以预期合理的方式运行，真正做到高性能mysql。</p><p>下面流程阐述了执行一条查询语句的时候，mysql到底在内部进行了哪些操作。</p><ol><li>客户端发送一条查询给服务器</li><li>服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。</li><li>服务器端进行sql解析、预处理，再由优化器生成对应的执行计划。</li><li>mysql根据优化器生成的执行计划，调用存储引擎的API来执行查询。</li><li>将结果返回给客户端</li></ol><p>从以上步骤可以看出查询优化工作实际上就是根据一些规则使得优化器能够以预期合理的方式运行</p><h3 id="mysql执行计划"><a href="#mysql执行计划" class="headerlink" title="mysql执行计划"></a>mysql执行计划</h3><p>由mysql查询执行的基础步骤可知，当客户端发送给mysql 服务器一条查询语句后，服务器端进行sql解析、预处理，再由优化器生成对应的执行计划。使用 EXPLAIN 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MYSQL 是如何处理你的 sql 语句的。分析你的查询语句或是表结构的性能瓶颈。</p><p>我们执行下面语句查看其相对应的mysql执行计划</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">explainselect * from t1 <span class="hljs-built_in">where</span> content=<span class="hljs-string">&quot;test&quot;</span> order by idDESC <span class="hljs-built_in">limit</span> 1;<br></code></pre></td></tr></table></figure><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>t1</td><td></td><td>index</td><td></td><td>PRIMARY</td><td>4</td><td></td><td>1</td><td>100</td><td>Using where</td></tr></tbody></table><p>根据以上mysql执行计划我们对其包含的指标进行一一分析。</p><h5 id="1，id简析"><a href="#1，id简析" class="headerlink" title="1，id简析"></a>1，id简析</h5><ul><li>​    id相同执行顺序由上至下</li></ul><p>​    执行一下语句</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">explain select * from <span class="hljs-built_in">t1</span>,<span class="hljs-built_in">t2</span>,<span class="hljs-built_in">t3</span> where <span class="hljs-built_in">t1</span>.id=<span class="hljs-built_in">t2</span>.id <span class="hljs-keyword">and </span><span class="hljs-built_in">t2</span>.id=<span class="hljs-built_in">t3</span>.id<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">id</th><th align="center">select_type</th><th align="center">table</th><th>type</th><th align="center">possible_keys</th><th align="center">key</th><th>key_lean</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">SIMPLE</td><td align="center">t1</td><td>index</td><td align="center">PRIMARY</td><td align="center"></td><td></td><td></td><td>1</td><td>100</td><td></td></tr><tr><td align="center">1</td><td align="center">SIMPLE</td><td align="center">t2</td><td>eq_ref</td><td align="center">PRIMARY</td><td align="center">PRIMARY</td><td>2</td><td>test.t1.id</td><td>1</td><td>100</td><td></td></tr><tr><td align="center">1</td><td align="center">SIMPLE</td><td align="center">t3</td><td>eq_ref</td><td align="center">PRIMARY</td><td align="center">PRIMARY</td><td>4</td><td>test.t1.id</td><td>1</td><td>100</td><td></td></tr></tbody></table><ul><li><p>​    id不同，如果是子查询，id的序号会递增，id越大优先级越高，越先被执行</p></li><li><p>​    id相同和不用的情况同时存在，id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行</p></li></ul><h5 id="2，select-type"><a href="#2，select-type" class="headerlink" title="2，select_type"></a>2，select_type</h5><ul><li>select_type表示查询的类型，主要用来区别普通查询、联合查询、子查询等复杂查询</li></ul><h5 id="3，table"><a href="#3，table" class="headerlink" title="3，table"></a>3，table</h5><ul><li>table显示这一张的数据是关于哪张表的</li></ul><h5 id="4，type"><a href="#4，type" class="headerlink" title="4，type"></a>4，type</h5><p>type显示查询使用了何种类型，从最好到最差依次是：system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</p><ul><li><p>system：表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计</p></li><li><p>const：表示通过索引一次就找到了,const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL就能将该查询转换为一个常量</p></li><li><p>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描</p></li><li><p>ref：非唯一性索引扫描，返回匹配某个单独值的所有行.本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体</p></li><li><p>range：只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引，一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询。这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。</p></li><li><p>index：Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小。（也就是说虽然all和Index都是读全表，但index是从索引中读取的，而all是从硬盘中读的）</p></li><li><p>all：Full Table Scan，将遍历全表以找到匹配的行</p></li><li><p>index_merge：在查询过程中需要多个索引组合使用，通常出现在有 or 的关键字的sql中</p></li><li><p>ref_or_null：对于某个字段既需要关联条件，也需要null值得情况下。查询优化器会选择用ref_or_null连接查询。</p></li><li><p>index_subquery：利用索引来关联子查询，不再全表扫描。</p></li><li><p>unique__subquery：该联接类型类似于index_subquery。 子查询中的唯一索引</p><blockquote><p>备注：一般来说，得保证查询至少达到range级别，最好能达到ref。</p></blockquote></li></ul><h5 id="5，possible-key"><a href="#5，possible-key" class="headerlink" title="5，possible_key"></a>5，possible_key</h5><p>possible_key显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用</p><h5 id="6，key"><a href="#6，key" class="headerlink" title="6，key"></a>6，key</h5><p>key实际使用的索引。如果为NULL，则没有使用索引，查询中若使用了覆盖索引，则该索引和查询的select字段重叠</p><h5 id="7，key-len"><a href="#7，key-len" class="headerlink" title="7，key_len"></a>7，key_len</h5><p>key_len表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。key_len字段能够帮你检查是否充分的利用上了索引</p><h5 id="8，ref"><a href="#8，ref" class="headerlink" title="8，ref"></a>8，ref</h5><p>ref显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值</p><h5 id="9，rows"><a href="#9，rows" class="headerlink" title="9，rows"></a>9，rows</h5><p>rows列显示mysql认为它执行查询时必须检查的行数，越小越好</p><h5 id="10，Extra"><a href="#10，Extra" class="headerlink" title="10，Extra"></a>10，Extra</h5><p>Extra包含不适合在其他列中显示但十分重要的额外信息</p><ul><li>Using filesort：说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。<br>MySQL中无法利用索引完成的排序操作称为“文件排序”</li><li>Using temporary：使了用临时表保存中间结果,MySQL在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。</li><li>USING index：表示相应的select操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错！如果同时出现using where，表明索引被用来执行索引键值的查找;如果没有同时出现using where，表明索引只是用来读取数据而非利用索引执行查找。</li><li>Using where：表明使用了where过滤</li><li>using join buffer：使用了连接缓存：</li><li>impossible where：where子句的值总是false，不能用来获取任何元组</li><li>select tables optimized away：在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>浅析前缀索引及索引的选择性</title>
    <link href="/2021/11/29/%E6%B5%85%E6%9E%90%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E5%8F%8A%E7%B4%A2%E5%BC%95%E7%9A%84%E9%80%89%E6%8B%A9%E6%80%A7/"/>
    <url>/2021/11/29/%E6%B5%85%E6%9E%90%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E5%8F%8A%E7%B4%A2%E5%BC%95%E7%9A%84%E9%80%89%E6%8B%A9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>有时候需要对一个很长的字符串添加索引，那么如何给长字符串添加索引呢？索引整个字符串？这样会让索引不但变得很大，而且会很慢，会大大降低检索性能。那使用hash索引呢？hash索引也可以考虑，但考虑到hash索引使用场景的局限性，有时候这么做并不够，那有什么好的方法对长字符串添加索引呢？</p><p>我们可以对截取字符串的部分构件索引，这样在查询的时候会更加灵活，而且会大大节省空间，提高检索的效率。但我们在实践中需要考虑的一个问题是，我们选取字符串的部分长度在什么区间作为索引会比较合理呢？这就不得不引入一个概念：索引的选择性。实际上前缀索引会降低索引的选择性。</p><p>所谓索引的选择性是指，不重复的索引值（也称为基数）和数据表的记录总数（#T）的比值，范围从1/#T到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p><p>选择前缀索引的诀窍在于要选择合适的前缀以保证较高的选择性，同时还不能太长，占用太多的空间。前缀索引应该足够长，以使得前缀索引的选择性接近于索引整个列。</p><p>下载以下sql文件我们用实验来说明索引的选择性</p><p><a href="%E4%B8%8B%E8%BD%BD%E5%AE%9E%E9%AA%8C%E6%89%80%E7%94%A8%E7%9A%84sql%E6%96%87%E4%BB%B6">https://downloads.mysql.com/docs/sakila-db.zip</a></p><p>用city表生成一个示例表</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> sakila.city_demo(city <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>);<br>    <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> sakila.city_demo(city) <span class="hljs-keyword">SELECT</span> city <span class="hljs-keyword">FROM</span> sakila.city;<br>    <span class="hljs-keyword">UPDATE</span> sakila.city_demo<br>       <span class="hljs-keyword">SET</span> city = (<span class="hljs-keyword">SELECT</span> city <span class="hljs-keyword">FROM</span> sakila.city <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> RAND() <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>生成的数据都是随机的，运行下面的sql语句我们查询出最常见的城市列表：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">COUNT</span>(*) <span class="hljs-keyword">as</span> cnt,city<br><span class="hljs-keyword">from</span> sakila.city_demo <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> city <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> cnt <span class="hljs-keyword">DESC</span> <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th>cnt</th><th>city</th></tr></thead><tbody><tr><td>97</td><td>London</td></tr><tr><td>70</td><td>Matamoros</td></tr><tr><td>68</td><td>Ourense (Orense)</td></tr><tr><td>68</td><td>Greensboro</td></tr><tr><td>67</td><td>Iwaki</td></tr><tr><td>66</td><td>Konotop</td></tr><tr><td>66</td><td>Guadalajara</td></tr><tr><td>66</td><td>Katihar</td></tr><tr><td>65</td><td>Kuching</td></tr><tr><td>64</td><td>Usak</td></tr></tbody></table><p>现在查找到最频繁出现的城市前缀，先从三个字母开始，运行以下sql语句：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">COUNT</span>(*) <span class="hljs-keyword">as</span> cnt,<span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">3</span>) <span class="hljs-keyword">as</span> pref<br><span class="hljs-keyword">from</span> sakila.city_demo <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> pref <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> cnt <span class="hljs-keyword">DESC</span> <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>结果如下：</p><table><thead><tr><th align="center">cnt</th><th>pref</th></tr></thead><tbody><tr><td align="center">681</td><td>San</td></tr><tr><td align="center">297</td><td>Cha</td></tr><tr><td align="center">275</td><td>Sou</td></tr><tr><td align="center">266</td><td>al-</td></tr><tr><td align="center">246</td><td>Sal</td></tr><tr><td align="center">238</td><td>Tan</td></tr><tr><td align="center">210</td><td>Sha</td></tr><tr><td align="center">201</td><td>Bat</td></tr><tr><td align="center">199</td><td>Hal</td></tr><tr><td align="center">199</td><td>Val</td></tr></tbody></table><p>每个前缀都比原来的城市出现的次数更多，因此唯一前缀比唯一城市要少得多。然后我们增加前缀长度，直到这个前缀的选择性接近完整列的选择性。经过实验后发现前缀长度为7时比较合适：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">COUNT</span>(*) <span class="hljs-keyword">as</span> cnt,<span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">7</span>) <span class="hljs-keyword">as</span> pref<br><span class="hljs-keyword">from</span> sakila.city_demo <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> pref <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> cnt <span class="hljs-keyword">DESC</span> <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>查询结果为：</p><table><thead><tr><th align="center">cnt</th><th>pref</th></tr></thead><tbody><tr><td align="center">108</td><td>Valle d</td></tr><tr><td align="center">102</td><td>Santiag</td></tr><tr><td align="center">97</td><td>London</td></tr><tr><td align="center">90</td><td>San Fel</td></tr><tr><td align="center">70</td><td>Matamor</td></tr><tr><td align="center">68</td><td>Ourense</td></tr><tr><td align="center">68</td><td>Greensb</td></tr><tr><td align="center">67</td><td>Iwaki</td></tr><tr><td align="center">66</td><td>Katihar</td></tr><tr><td align="center">66</td><td>Konotop</td></tr></tbody></table><p>计算合适的前缀长度的另外一个办法就是计算完整列的选择性，并使前缀的选择性接近于完整列的选择性。运行以下sql语句计算列的选择性：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> city)<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> sakila.city_demo;<br></code></pre></td></tr></table></figure><p>结果如下：</p><table><thead><tr><th align="center">COUNT(DISTINCT city)/COUNT(*)</th></tr></thead><tbody><tr><td align="center">0.02</td></tr></tbody></table><p>通常来说，这个例子中如果前缀的选择性能够接近0.2，基本上就可用了。</p><p>下面的sql语句给出了如何在同一个查询中计算不同前缀长度的选择性：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> city)<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sal, <br> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">3</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sal3,<br> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">4</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sal4,<br> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">5</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sal5, <br> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">6</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sal6, <br> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">7</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sal7, <br> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">8</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sal8, <br> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">9</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sal9, <br> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">10</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sal10,<br> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">11</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sal11,<br> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">12</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sal12, <br> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">13</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sal13, <br> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">14</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sal14, <br> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">15</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sal15,  <br> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">16</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sal16 <br> <span class="hljs-keyword">FROM</span> sakila.city_demo;<br></code></pre></td></tr></table></figure><table><thead><tr><th>sal</th><th>sal3</th><th>sal4</th><th>sal5</th><th>sal6</th><th>sal7</th><th>sal8</th><th>sal9</th><th>sal10</th><th>sal11</th><th>sal12</th><th>sal13</th><th>sal14</th><th>sal15</th><th>sal16</th></tr></thead><tbody><tr><td>0.02</td><td>0.0153</td><td>0.0188</td><td>0.0195</td><td>0.0198</td><td>0.0199</td><td>0.0199</td><td>0.0199</td><td>0.0199</td><td>0.0199</td><td>0.0199</td><td>0.0199</td><td>0.02</td><td>0.02</td><td>0.02</td></tr></tbody></table><p>查询显示当前缀长度到达7的时候，再增加前缀长度，选择性提升的幅度已经很小了。</p><p>需要注意的是只看平均选择性是不够的，也有例外的情况，需要考虑最坏情况下的选择性。平均选择性会让你认为前缀长度为4或者5的索引已经足够了，但如果数据分布很不均匀，可能就会有陷阱。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/10/17/hello-world/"/>
    <url>/2021/10/17/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
