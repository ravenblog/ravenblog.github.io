<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>mysql执行计划分析</title>
    <link href="/2021/11/29/mysql%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E5%88%86%E6%9E%90/"/>
    <url>/2021/11/29/mysql%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>如何能使mysql以更高的性能执行查询语句?要回答这一问题我们首先需要弄清楚mysql内部是怎么执行查询语句的，只要知道了这一点，找出mysql在执行过程中的性能瓶颈，做针对性的优化就能使查询语句以预期合理的方式运行，真正做到高性能mysql。</p><h2 id="mysql执行计划分析"><a href="#mysql执行计划分析" class="headerlink" title="mysql执行计划分析"></a>mysql执行计划分析</h2><h3 id="mysql查询执行的基础"><a href="#mysql查询执行的基础" class="headerlink" title="mysql查询执行的基础"></a>mysql查询执行的基础</h3><p>如何能使mysql以更高的性能执行查询语句?要回答这一问题我们首先需要弄清楚mysql内部是怎么执行查询语句的，做到不仅到知其然而且知其所以然。只要知道了这一点，找出mysql在执行过程中的性能瓶颈，做针对性的优化就能使查询语句以预期合理的方式运行，真正做到高性能mysql。</p><p>下面流程阐述了执行一条查询语句的时候，mysql到底在内部进行了哪些操作。</p><ol><li>客户端发送一条查询给服务器</li><li>服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。</li><li>服务器端进行sql解析、预处理，再由优化器生成对应的执行计划。</li><li>mysql根据优化器生成的执行计划，调用存储引擎的API来执行查询。</li><li>将结果返回给客户端</li></ol><p>从以上步骤可以看出查询优化工作实际上就是根据一些规则使得优化器能够以预期合理的方式运行</p><h3 id="mysql执行计划"><a href="#mysql执行计划" class="headerlink" title="mysql执行计划"></a>mysql执行计划</h3><p>由mysql查询执行的基础步骤可知，当客户端发送给mysql 服务器一条查询语句后，服务器端进行sql解析、预处理，再由优化器生成对应的执行计划。使用 EXPLAIN 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MYSQL 是如何处理你的 sql 语句的。分析你的查询语句或是表结构的性能瓶颈。</p><p>我们执行下面语句查看其相对应的mysql执行计划</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">explainselect * from t1 <span class="hljs-built_in">where</span> content=<span class="hljs-string">&quot;test&quot;</span> order by idDESC <span class="hljs-built_in">limit</span> 1;<br></code></pre></td></tr></table></figure><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>t1</td><td></td><td>index</td><td></td><td>PRIMARY</td><td>4</td><td></td><td>1</td><td>100</td><td>Using where</td></tr></tbody></table><p>根据以上mysql执行计划我们对其包含的指标进行一一分析。</p><h5 id="1，id简析"><a href="#1，id简析" class="headerlink" title="1，id简析"></a>1，id简析</h5><ul><li>​    id相同执行顺序由上至下</li></ul><p>​    执行一下语句</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">explain select * from <span class="hljs-built_in">t1</span>,<span class="hljs-built_in">t2</span>,<span class="hljs-built_in">t3</span> where <span class="hljs-built_in">t1</span>.id=<span class="hljs-built_in">t2</span>.id <span class="hljs-keyword">and </span><span class="hljs-built_in">t2</span>.id=<span class="hljs-built_in">t3</span>.id<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">id</th><th align="center">select_type</th><th align="center">table</th><th>type</th><th align="center">possible_keys</th><th align="center">key</th><th>key_lean</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">SIMPLE</td><td align="center">t1</td><td>index</td><td align="center">PRIMARY</td><td align="center"></td><td></td><td></td><td>1</td><td>100</td><td></td></tr><tr><td align="center">1</td><td align="center">SIMPLE</td><td align="center">t2</td><td>eq_ref</td><td align="center">PRIMARY</td><td align="center">PRIMARY</td><td>2</td><td>test.t1.id</td><td>1</td><td>100</td><td></td></tr><tr><td align="center">1</td><td align="center">SIMPLE</td><td align="center">t3</td><td>eq_ref</td><td align="center">PRIMARY</td><td align="center">PRIMARY</td><td>4</td><td>test.t1.id</td><td>1</td><td>100</td><td></td></tr></tbody></table><ul><li><p>​    id不同，如果是子查询，id的序号会递增，id越大优先级越高，越先被执行</p></li><li><p>​    id相同和不用的情况同时存在，id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行</p></li></ul><h5 id="2，select-type"><a href="#2，select-type" class="headerlink" title="2，select_type"></a>2，select_type</h5><ul><li>select_type表示查询的类型，主要用来区别普通查询、联合查询、子查询等复杂查询</li></ul><h5 id="3，table"><a href="#3，table" class="headerlink" title="3，table"></a>3，table</h5><ul><li>table显示这一张的数据是关于哪张表的</li></ul><h5 id="4，type"><a href="#4，type" class="headerlink" title="4，type"></a>4，type</h5><p>type显示查询使用了何种类型，从最好到最差依次是：system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</p><ul><li><p>system：表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计</p></li><li><p>const：表示通过索引一次就找到了,const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL就能将该查询转换为一个常量</p></li><li><p>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描</p></li><li><p>ref：非唯一性索引扫描，返回匹配某个单独值的所有行.本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体</p></li><li><p>range：只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引，一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询。这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。</p></li><li><p>index：Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小。（也就是说虽然all和Index都是读全表，但index是从索引中读取的，而all是从硬盘中读的）</p></li><li><p>all：Full Table Scan，将遍历全表以找到匹配的行</p></li><li><p>index_merge：在查询过程中需要多个索引组合使用，通常出现在有 or 的关键字的sql中</p></li><li><p>ref_or_null：对于某个字段既需要关联条件，也需要null值得情况下。查询优化器会选择用ref_or_null连接查询。</p></li><li><p>index_subquery：利用索引来关联子查询，不再全表扫描。</p></li><li><p>unique__subquery：该联接类型类似于index_subquery。 子查询中的唯一索引</p><blockquote><p>备注：一般来说，得保证查询至少达到range级别，最好能达到ref。</p></blockquote></li></ul><h5 id="5，possible-key"><a href="#5，possible-key" class="headerlink" title="5，possible_key"></a>5，possible_key</h5><p>possible_key显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用</p><h5 id="6，key"><a href="#6，key" class="headerlink" title="6，key"></a>6，key</h5><p>key实际使用的索引。如果为NULL，则没有使用索引，查询中若使用了覆盖索引，则该索引和查询的select字段重叠</p><h5 id="7，key-len"><a href="#7，key-len" class="headerlink" title="7，key_len"></a>7，key_len</h5><p>key_len表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。key_len字段能够帮你检查是否充分的利用上了索引</p><h5 id="8，ref"><a href="#8，ref" class="headerlink" title="8，ref"></a>8，ref</h5><p>ref显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值</p><h5 id="9，rows"><a href="#9，rows" class="headerlink" title="9，rows"></a>9，rows</h5><p>rows列显示mysql认为它执行查询时必须检查的行数，越小越好</p><h5 id="10，Extra"><a href="#10，Extra" class="headerlink" title="10，Extra"></a>10，Extra</h5><p>Extra包含不适合在其他列中显示但十分重要的额外信息</p><ul><li>Using filesort：说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。<br>MySQL中无法利用索引完成的排序操作称为“文件排序”</li><li>Using temporary：使了用临时表保存中间结果,MySQL在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。</li><li>USING index：表示相应的select操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错！如果同时出现using where，表明索引被用来执行索引键值的查找;如果没有同时出现using where，表明索引只是用来读取数据而非利用索引执行查找。</li><li>Using where：表明使用了where过滤</li><li>using join buffer：使用了连接缓存：</li><li>impossible where：where子句的值总是false，不能用来获取任何元组</li><li>select tables optimized away：在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>浅析前缀索引及索引的选择性</title>
    <link href="/2021/11/29/%E6%B5%85%E6%9E%90%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E5%8F%8A%E7%B4%A2%E5%BC%95%E7%9A%84%E9%80%89%E6%8B%A9%E6%80%A7/"/>
    <url>/2021/11/29/%E6%B5%85%E6%9E%90%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E5%8F%8A%E7%B4%A2%E5%BC%95%E7%9A%84%E9%80%89%E6%8B%A9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>有时候需要对一个很长的字符串添加索引，那么如何给长字符串添加索引呢？索引整个字符串？这样会让索引不但变得很大，而且会很慢，会大大降低检索性能。那使用hash索引呢？hash索引也可以考虑，但考虑到hash索引使用场景的局限性，有时候这么做并不够，那有什么好的方法对长字符串添加索引呢？</p><p>我们可以对截取字符串的部分构件索引，这样在查询的时候会更加灵活，而且会大大节省空间，提高检索的效率。但我们在实践中需要考虑的一个问题是，我们选取字符串的部分长度在什么区间作为索引会比较合理呢？这就不得不引入一个概念：索引的选择性。实际上前缀索引会降低索引的选择性。</p><p>所谓索引的选择性是指，不重复的索引值（也称为基数）和数据表的记录总数（#T）的比值，范围从1/#T到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p><p>选择前缀索引的诀窍在于要选择合适的前缀以保证较高的选择性，同时还不能太长，占用太多的空间。前缀索引应该足够长，以使得前缀索引的选择性接近于索引整个列。</p><p>下载以下sql文件我们用实验来说明索引的选择性</p><p><a href="%E4%B8%8B%E8%BD%BD%E5%AE%9E%E9%AA%8C%E6%89%80%E7%94%A8%E7%9A%84sql%E6%96%87%E4%BB%B6">https://downloads.mysql.com/docs/sakila-db.zip</a></p><p>用city表生成一个示例表</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> sakila.city_demo(city <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>);<br>    <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> sakila.city_demo(city) <span class="hljs-keyword">SELECT</span> city <span class="hljs-keyword">FROM</span> sakila.city;<br>    <span class="hljs-keyword">UPDATE</span> sakila.city_demo<br>       <span class="hljs-keyword">SET</span> city = (<span class="hljs-keyword">SELECT</span> city <span class="hljs-keyword">FROM</span> sakila.city <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> RAND() <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>生成的数据都是随机的，运行下面的sql语句我们查询出最常见的城市列表：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">COUNT</span>(*) <span class="hljs-keyword">as</span> cnt,city<br><span class="hljs-keyword">from</span> sakila.city_demo <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> city <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> cnt <span class="hljs-keyword">DESC</span> <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><table><thead><tr><th>cnt</th><th>city</th></tr></thead><tbody><tr><td>97</td><td>London</td></tr><tr><td>70</td><td>Matamoros</td></tr><tr><td>68</td><td>Ourense (Orense)</td></tr><tr><td>68</td><td>Greensboro</td></tr><tr><td>67</td><td>Iwaki</td></tr><tr><td>66</td><td>Konotop</td></tr><tr><td>66</td><td>Guadalajara</td></tr><tr><td>66</td><td>Katihar</td></tr><tr><td>65</td><td>Kuching</td></tr><tr><td>64</td><td>Usak</td></tr></tbody></table><p>现在查找到最频繁出现的城市前缀，先从三个字母开始，运行以下sql语句：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">COUNT</span>(*) <span class="hljs-keyword">as</span> cnt,<span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">3</span>) <span class="hljs-keyword">as</span> pref<br><span class="hljs-keyword">from</span> sakila.city_demo <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> pref <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> cnt <span class="hljs-keyword">DESC</span> <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>结果如下：</p><table><thead><tr><th align="center">cnt</th><th>pref</th></tr></thead><tbody><tr><td align="center">681</td><td>San</td></tr><tr><td align="center">297</td><td>Cha</td></tr><tr><td align="center">275</td><td>Sou</td></tr><tr><td align="center">266</td><td>al-</td></tr><tr><td align="center">246</td><td>Sal</td></tr><tr><td align="center">238</td><td>Tan</td></tr><tr><td align="center">210</td><td>Sha</td></tr><tr><td align="center">201</td><td>Bat</td></tr><tr><td align="center">199</td><td>Hal</td></tr><tr><td align="center">199</td><td>Val</td></tr></tbody></table><p>每个前缀都比原来的城市出现的次数更多，因此唯一前缀比唯一城市要少得多。然后我们增加前缀长度，直到这个前缀的选择性接近完整列的选择性。经过实验后发现前缀长度为7时比较合适：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">COUNT</span>(*) <span class="hljs-keyword">as</span> cnt,<span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">7</span>) <span class="hljs-keyword">as</span> pref<br><span class="hljs-keyword">from</span> sakila.city_demo <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> pref <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> cnt <span class="hljs-keyword">DESC</span> <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>查询结果为：</p><table><thead><tr><th align="center">cnt</th><th>pref</th></tr></thead><tbody><tr><td align="center">108</td><td>Valle d</td></tr><tr><td align="center">102</td><td>Santiag</td></tr><tr><td align="center">97</td><td>London</td></tr><tr><td align="center">90</td><td>San Fel</td></tr><tr><td align="center">70</td><td>Matamor</td></tr><tr><td align="center">68</td><td>Ourense</td></tr><tr><td align="center">68</td><td>Greensb</td></tr><tr><td align="center">67</td><td>Iwaki</td></tr><tr><td align="center">66</td><td>Katihar</td></tr><tr><td align="center">66</td><td>Konotop</td></tr></tbody></table><p>计算合适的前缀长度的另外一个办法就是计算完整列的选择性，并使前缀的选择性接近于完整列的选择性。运行以下sql语句计算列的选择性：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> city)<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> sakila.city_demo;<br></code></pre></td></tr></table></figure><p>结果如下：</p><table><thead><tr><th align="center">COUNT(DISTINCT city)/COUNT(*)</th></tr></thead><tbody><tr><td align="center">0.02</td></tr></tbody></table><p>通常来说，这个例子中如果前缀的选择性能够接近0.2，基本上就可用了。</p><p>下面的sql语句给出了如何在同一个查询中计算不同前缀长度的选择性：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> city)<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sal, <br> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">3</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sal3,<br> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">4</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sal4,<br> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">5</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sal5, <br> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">6</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sal6, <br> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">7</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sal7, <br> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">8</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sal8, <br> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">9</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sal9, <br> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">10</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sal10,<br> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">11</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sal11,<br> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">12</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sal12, <br> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">13</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sal13, <br> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">14</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sal14, <br> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">15</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sal15,  <br> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(city,<span class="hljs-number">16</span>))<span class="hljs-operator">/</span><span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> sal16 <br> <span class="hljs-keyword">FROM</span> sakila.city_demo;<br></code></pre></td></tr></table></figure><table><thead><tr><th>sal</th><th>sal3</th><th>sal4</th><th>sal5</th><th>sal6</th><th>sal7</th><th>sal8</th><th>sal9</th><th>sal10</th><th>sal11</th><th>sal12</th><th>sal13</th><th>sal14</th><th>sal15</th><th>sal16</th></tr></thead><tbody><tr><td>0.02</td><td>0.0153</td><td>0.0188</td><td>0.0195</td><td>0.0198</td><td>0.0199</td><td>0.0199</td><td>0.0199</td><td>0.0199</td><td>0.0199</td><td>0.0199</td><td>0.0199</td><td>0.02</td><td>0.02</td><td>0.02</td></tr></tbody></table><p>查询显示当前缀长度到达7的时候，再增加前缀长度，选择性提升的幅度已经很小了。</p><p>需要注意的是只看平均选择性是不够的，也有例外的情况，需要考虑最坏情况下的选择性。平均选择性会让你认为前缀长度为4或者5的索引已经足够了，但如果数据分布很不均匀，可能就会有陷阱。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/10/17/hello-world/"/>
    <url>/2021/10/17/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
